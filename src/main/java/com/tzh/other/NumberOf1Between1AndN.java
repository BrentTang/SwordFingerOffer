package com.tzh.other;

/**
 * @author Brent
 * @title: NumberOf1Between1AndN
 * @projectName Offer
 * @date 2019/9/23 15:54
 * @description: 整数中1出现的次数（从1到n整数中1出现的次数）
 *
 * 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？
 * 为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,
 * 但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,
 * 可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。
 *
 * 1. 如果百位上数字为0，百位上可能出现1的次数由更高位决定。
 *    比如：12013，则可以知道百位出现1的情况可能是：
 *    100 ~ 199，1100 ~ 1199，2100 ~ 2199，… 11100~11199，一共1200个。
 *    可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以当前位数（100）。
 * 2. 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。
 *    比如：12113，则可以知道百位受高位影响出现的情况是：
 *    100 ~ 199，1100 ~ 1199,2100 ~ 2199，…，11100~11199，一共1200个。
 *    和上面情况一样，并且等于更高位数字（12）乘以当前位数（100）。
 *    但同时它还受低位影响，百位出现1的情况是：12100 ~12113,一共114个，等于低位数字（113）+1。
 * 3. 如果百位上数字大于1（2 ~ 9），则百位上出现1的情况仅由更高位决定，
 *    比如12213，则百位出现1的情况是：
 *    100 ~ 199,1100 ~ 1199，2100 ~ 2199，…，11100 ~ 11199, 12100~12199,一共有1300个，
 *    并且等于更高位数字+1（12+1）乘以当前位数（100）。
 *
 * 时间限制：1秒 空间限制：32768K
 */
public class NumberOf1Between1AndN {

    public int NumberOf1Between1AndN_Solution(int n) {
        int count = 0;
        int bit = 1;
        while (n / bit != 0) {
            int before = n / bit / 10;
            int after = n % bit;
            int cur = (n / bit) % 10;
            if (cur == 0) {
                count += before * bit;
            } else if (cur == 1) {
                count += before * bit + after + 1;
            } else {
                count += (before + 1) * bit;
            }
            bit *= 10;
        }

        return count;
    }

    /*
    现在说十位数，十位数上出现1的情况应该是10-19，依然沿用分析个位数时候的阶梯理论，
    我们知道10-19这组数，每隔100出现一次，这次我们的阶梯是100，例如数字317，
    分析有阶梯0-99，100-199，200-299三段完整阶梯，每一段阶梯里面都会出现10次1（从10-19），
    最后分析露出来的那段不完整的阶梯。我们考虑如果露出来的数大于19，那么直接算10个1就行了，
    因为10-19肯定会出现；如果小于10，那么肯定不会出现十位数的1；如果在10-19之间的，
    我们计算结果应该是k - 10 + 1。例如我们分析300-317，17个数字，1出现的个数应该是17-10+1=8个。
    那么现在可以归纳：十位上1出现的个数为：
        • 设k = n % 100，即为不完整阶梯段的数字
        • 归纳式为：(n / 100) * 10 + (if(k > 19) 10 else if(k < 10) 0 else k - 10 + 1)
     */
    /*public int NumberOf1Between1AndN_Solution(int n) {
        if(n <= 0)
            return 0;
        int count = 0;
        for(long i = 1; i <= n; i *= 10){
            long diviver = i * 10;
            count += (n / diviver) * i + Math.min(Math.max(n % diviver - i + 1, 0), i);
        }
        return count;
    }*/

}
